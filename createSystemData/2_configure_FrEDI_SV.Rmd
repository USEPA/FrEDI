---
title: "Configure FrEDI SV Data"
author: "Industrial Economics, Inc."
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  rmarkdown::html_document:
    theme: spacelab
    toc: true
    toc_float: true
---

<style>
/* Simplified version of Bootstrap's responsive table CSS */
.table-responsive {
    display: block;
    width: 100%;
    overflow-x: auto;
}

.table-responsive > table {
    width: 100%;
}
</style>


```{r knitr setup, include=FALSE}
### The following parameters declare the options for compiling the Markdown document.
knitr::opts_chunk$set(
  include = T,     ### Evaluate and depict outputs of code chunks in the compiled document
  echo    = T,     ### Echo the commands of the code chunks in the compiled document
  message = FALSE, ### Don't include command-line messages output from evaluating code chunks
  cache   = FALSE, ### Don't cache the evaluation of code chunks
  warning = FALSE,  ### Don't include warnings from evaluating code chunks
  table.format = "html" 
)
```

## Overview

The purpose of this package is to configure the SV module for the R package after configuring the main FrEDI tool. First run "1_configure_FrEDI_main.Rmd"  prior to running "2_configure_FrEDI_SV.Rmd".

Load packages 

```{r loadPackages}
### Packages
require(tidyverse)
require(openxlsx)
require(devtools)
```


Set paths


```{r declare paths}
### Set print options
options(digits = 20)
### Set system paths
# projectPath      <- getwd()
projectPath      <- "."
today            <- format(Sys.Date(), "%Y%m%d")

### Path to fredi project
projectParentDir <- projectPath %>% file.path("..")
projectParentDir %>% list.files
frediPath        <- projectParentDir %>% file.path("FrEDI")

# ### Project configuration
# configPath       <- projectPath %>% file.path("config")
# # configFiles      <- configPath %>% list.files(".R")
# configFiles      <- "frediConfig.R"

### Code path
codePath         <- projectPath %>% file.path("R")
codeNames        <- codePath %>% list.files(".R")
# configLogPath    <- codePath %>% file.path("configLog")
# 
# ### Names for archive and use versions
# configFileName   <- "fredi_config"
# configArchName   <- configLogPath %>% file.path(configFileName) %>% paste(today, sep="_") %>% paste0(".rda")
# configUseName    <- codePath %>% file.path(configFileName) %>% paste0(".rda")

### Output path
dataOutPath      <- projectPath %>% file.path("data")
dataOutLog       <- dataOutPath %>% file.path("dataLog")
sysFileName      <- "sysdata"
# sysArchName      <- dataOutLog %>% file.path(sysFileName) %>% paste(today, sep="_") %>% paste0(".rda")
sysUseName       <- dataOutPath %>% file.path(sysFileName) %>% paste0(".rds")
```


## Update SV

### SV Sectors

List of SV sectors ("Air Quality", "Coastal Properties", "Extreme Temperature", "High Tide Flooding and Traffic", "Labor", "Roads")

Select a specific sector if not all sectors have been updated.


```{r c_sv_sectors}
c_sv_sectors     <- FrEDI::get_sv_sectorInfo()

### Uncomment the following line and select specific sectors to update select sectors rather than all sectors
c_sv_sectors     <- c("Roads")
```

### Screening

Create a list with arguments on which aspects of the SV data to update (takes awhile to update impact functions so we divide the process into parts):

* `save`: Logical. Set `save=TRUE` to save the configuration lists to file
* `sv`: Logical. Set `sv=TRUE` to update the SV demographic data (good practice to update if `pop=TRUE` or `format=TRUE`)
* `pop`: Logical. Set `pop=TRUE` if the population data has changed
* `format`: Logical. Set `format=TRUE` if any aspect of the Excel template (layout, unit descriptions, etc.) has changed
* `impacts`: Logical. Set `impacts=TRUE` if any of the underlying sector impact data has changed
* `sectors`: Character vector. Specify which sectors to update if `impacts=TRUE` (defaults to all sectors)


```{r list_screening}
list_screening <- list(
  save     = TRUE,  ### Save SV
  sv       = TRUE,  ### Update SV demographic data
  pop      = FALSE, ### Update SV population data
  format   = TRUE,  ### Update formats
  impacts  = TRUE, ### Update impact lists
  sectors  = c_sv_sectors
)
```


### Update Configuration Data

Run `createSVData()` with arguments created in `list_screening` to update SV configuration.

```{r run createSVData}
## Uncomment following six lines to create and save data and check the outputs
for(name_i in codeNames){ source(paste(codePath, name_i, sep="/")) }
time1       <- Sys.time()
test_svData <- createSVData(
  save    = list_screening$save, 
  sv      = list_screening$sv, 
  format  = list_screening$format, 
  impacts = list_screening$impacts, 
  sectors = list_screening$sectors
)
time2       <- Sys.time()
time_create <- time2 - time1; time_create
```


### Update FrEDI Data

Use the following code to update the FrEDI system data with the SV configuration data.

```{r update_sysdata}
for(name_i in codeNames){ source(paste(codePath, name_i, sep="/")) }
codeNames
time3 <- Sys.time()
update_sysdata(
  save    = list_screening$save,
  # sv      = list_screening$sv, 
  sv      = FALSE, 
  impacts = list_screening$impacts
  )
time4       <- Sys.time()
time_update <- time4 - time3; time_update
```

## Test Package

### Create Test Inputs

Create a list of inputs to test

1. Set specifications for inputs:

```{r inputSpecs}
### Values above maximum values
inputSpecs <- list(temps = list(min=-1, max=11), 
                   slr   = list(min=-1, max=270),
                   years = list(min=2000, max=2090))
```

Create list of inputs

```{r testInputs}
testInputs <- inputSpecs %>% (function(list_x){
  years_i   <- seq(list_x$years$min, list_x$years$max, by=1)
  n_years_i <- years_i %>% length()
  h_years_i <- (n_years_i / 2) %>% floor()
  ### Values below minimum
  min_i <- list(
    tempInput = data.frame(year = years_i, temp_C = list_x$temps$min),
    slrInput  = data.frame(year = years_i, slr_cm = list_x$slr$min)
  )
  
  ### Values above maximum values
  max_i <- list(
    tempInput = data.frame(year = years_i, temp_C = list_x$temps$max),
    slrInput  = data.frame(year = years_i, slr_cm = list_x$slr$max)
  )
  ### Step between minimum and maximum
  step_i <- list(
    tempInput = data.frame(year = years_i[1:h_years_i], temp_C = list_x$temps$min) %>%
      rbind(data.frame(year = years_i[(h_years_i + 1):n_years_i], temp_C = list_x$temps$max)),
    slrInput  = data.frame(year = years_i[1:h_years_i], slr_cm = list_x$slr$min) %>%
      rbind(data.frame(year = years_i[(h_years_i + 1):n_years_i], slr_cm = list_x$slr$max))
  )
   ### Increasing between minimum and maximum
  ramp_i <- list(
    tempInput = data.frame(year   = years_i, 
                           temp_C = seq(list_x$temps$min, list_x$temps$max, length.out=n_years_i)),
    slrInput  = data.frame(year   = years_i, 
                           slr_cm = seq(list_x$slr$min , list_x$slr$max, length.out=n_years_i))
  )
  
  ### Add to list
  list_i <- list(maxi = max_i, mini = min_i, step = step_i, ramp = ramp_i)
  ### Return
  return(list_i)
})
```


### Paths for Saving Results

```{r resultsPath}
frediPath %>% file.path("..", "analysis", "qc") %>% list.files()
resultsPath <- frediPath %>% file.path("..", "analysis", "qc", today)
if(!dir.exists(resultsPath)){resultsPath %>% dir.create}
```

Test SV tool:

* Iterates over sectors in `list_screening$sectors`
* Set `all=FALSE` to run first sector only
* Set `all=TRUE` to run all sectors
* Returns info for last sector

```{r test sv}
frediPath %>% load_all
test_sv <- 
  # FrEDI::get_sv_sectorInfo() %>% 
  # c_sv_sectors %>% 
  # c("Air Quality") %>%
  FrEDI::get_sv_sectorInfo() %>% (function(x){x[which(!(x %in% c("Roads", "Labor", "Air Quality")))]}) %>%
  (function(
    sectors, 
    all = FALSE,
    inputs = testInputs[4],
    outpath = resultsPath, save = TRUE, addDate = T
){
  ### SLR sectors
  c_slr <- FrEDI::get_sv_sectorInfo(slrOnly = TRUE)
  ### Only run one sector
  if(!all){sectors <- sectors[1]}
  ### Scenarios
  c_scenarios_x <- inputs %>% names
  ### Create drivers if not null
  if(is.null(inputs)){
    inputs_x <- NULL
  }
  else{
    inputs_x <- c_scenarios_x %>% lapply(function(name_i, dataList = inputs){
      # name_j %>% print
      list_i   <- inputs[[name_i]]
      temp_i   <- list_i$tempInput
      slr_i    <- list_i$slrInput
      inputs_i <- temp_i %>% left_join(slr_i, by = c("year")) %>% mutate(scenario = name_i)
      return(inputs_i)
    }) %>% (function(names_i){do.call(rbind, names_i)})
  }
  paste0("Input names: ", paste(inputs_x %>% names, collapse=", "), "...") %>% message()
  c_check_x <- inputs_x$scenario %>% unique; c_check_x %>% print
  check_x   <- all(c_check_x %in% c_scenarios_x) & all(c_scenarios_x %in% c_check_x)
  
  ### Run scenarios if all are present
  if(check_x){
    ### Iterate over sectors
    results_x <- sectors %>% lapply(function(sector_i, inputs_i=inputs_x){
      paste0("Running ", sector_i, "...") %>% message()
      sysTime_x <- Sys.time()
      ### Driver inputs
      if(sector_i %in% c_slr){df_dri <- inputs_i %>% select(c("year", "slr_cm", "scenario"))}
      else{df_dri <- inputs_i %>% select(c("year", "temp_C", "scenario"))}
      sv_i <- run_fredi_sv(
        sector = sector_i, 
        driverInput = df_dri,
        outpath = outpath, save = save, addDate = addDate,
        silent=FALSE
      )
      sysTime_y <- Sys.time(); (sysTime_y - sysTime_x) %>% print
      return(sv_i)
    }) %>% (function(sectors_i){do.call(rbind, sectors_i)})
    return(results_x)
  }
})
test_sv %>% glimpse
```


Make sure at least some values are not missing:

```{r}
test_sv$scenario %>% unique
test_sv$aveRate_sv %>% (function(x, na=F){(!(x %>% is.na)) %>% which %>% length})
test_sv$aveRate_sv %>% (function(x, na=T){   x %>% is.na   %>% which %>% length})
test_sv$aveRate_sv %>% (function(x, na=F){(!(x == 0)) %>% which %>% length})
```



## Build Package

If tests are passed, run `3_build_FrEDI.Rmd` to build the package.



